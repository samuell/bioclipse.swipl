<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>SWI-Prolog 5.7.15 Reference Manual: Section 4.29</TITLE><LINK REL=home HREF="index.html">
<LINK REL=contents HREF="Contents.html">
<LINK REL=index HREF="DocIndex.html">
<LINK REL=summary HREF="summary.html">
<LINK REL=previous HREF="miscarith.html">
<LINK REL=next HREF="allsolutions.html">
<STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">
<DIV class="navigate"><A class="nav" href="index.html"><IMG SRC="home.gif" BORDER=0 ALT="Home"></A>
<A class="nav" href="Contents.html"><IMG SRC="index.gif" BORDER=0 ALT="Contents"></A>
<A class="nav" href="DocIndex.html"><IMG SRC="yellow_pages.gif" BORDER=0 ALT="Index"></A>
<A class="nav" href="summary.html"><IMG SRC="info.gif" BORDER=0 ALT="Summary"></A>
<A class="nav" href="miscarith.html"><IMG SRC="prev.gif" BORDER=0 ALT="Previous"></A>
<A class="nav" href="allsolutions.html"><IMG SRC="next.gif" BORDER=0 ALT="Next"></A>
</DIV>

<H2><A NAME="sec:4.29"><SPAN class="sec-nr">4.29</SPAN> <SPAN class="sec-title">Built-in 
list operations</SPAN></A></H2>

<A NAME="sec:builtinlist"></A>

<P>Most list operations are defined in the library <CODE>library(lists)</CODE> 
described in <A class="sec" href="lists.html">section A.12</A>. Some 
that are implemented with more low-level primitives are built-in and 
described here.

<DL>
<DT class="pubdef"><A NAME="is_list/1"><STRONG>is_list</STRONG>(<VAR>+Term</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Term</VAR> is bound to the empty list (<CODE>[]</CODE>) or 
a term with functor `<CODE><CODE>.</CODE></CODE>' and arity&nbsp;2 and 
the second argument is a list.<SUP class="fn">54<SPAN class="fn-text">In 
versions before 5.0.1, <A NAME="idx:islist1:1002"></A><A class="pred" href="builtinlist.html#is_list/1">is_list/1</A> 
just checked for <CODE>[]</CODE> or <CODE>[_|_]</CODE> and proper_list/1 
had the role of the current <A NAME="idx:islist1:1003"></A><A class="pred" href="builtinlist.html#is_list/1">is_list/1</A>. 
The current definition conforms to the de-facto standard. Assuming 
proper coding standards, there should only be very few cases where a 
quick-and-dirty <A NAME="idx:islist1:1004"></A><A class="pred" href="builtinlist.html#is_list/1">is_list/1</A> 
is a good choice. Richard O'Keefe pointed at this issue.</SPAN></SUP> 
This predicate acts as if defined by the definition below on
<EM>acyclic</EM> terms. The implementation <EM>fails</EM> safely if
<VAR>Term</VAR> represents a cyclic list.

<PRE class="code">
is_list(X) :-
        var(X), !,
        fail.
is_list([]).
is_list([_|T]) :-
        is_list(T).
</PRE>

</DD>
<DT class="pubdef"><A NAME="memberchk/2"><STRONG>memberchk</STRONG>(<VAR>?Elem, 
+List</VAR>)</A></DT>
<DD class="defbody">
Same as <CODE>once(member(<VAR>Elem</VAR>, <VAR>List</VAR>))</CODE>.</DD>
<DT class="pubdef"><A NAME="length/2"><STRONG>length</STRONG>(<VAR>?List, 
?Int</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Int</VAR> represents the number of elements of list <VAR>List</VAR>. 
Can be used to create a list holding only variables.</DD>
<DT class="pubdef"><A NAME="sort/2"><STRONG>sort</STRONG>(<VAR>+List, 
-Sorted</VAR>)</A></DT>
<DD class="defbody">
True if <VAR>Sorted</VAR> can be unified with a list holding the 
elements of <VAR>List</VAR>, sorted to the standard order of terms (see
<A class="sec" href="compare.html">section 4.6</A>). Duplicates are 
removed. The implementation is in C, using <EM>natural merge sort</EM>.<SUP class="fn">55<SPAN class="fn-text">Contributed 
by Richard O'Keefe.</SPAN></SUP> The <A NAME="idx:sort2:1005"></A><A class="pred" href="builtinlist.html#sort/2">sort/2</A> 
predicate can sort a cyclic list, returning a non-cyclic version with 
the same elements.</DD>
<DT class="pubdef"><A NAME="msort/2"><STRONG>msort</STRONG>(<VAR>+List, 
-Sorted</VAR>)</A></DT>
<DD class="defbody">
Equivalent to <A NAME="idx:sort2:1006"></A><A class="pred" href="builtinlist.html#sort/2">sort/2</A>, 
but does not remove duplicates. Fails with a <CODE>type_error</CODE> if <VAR>List</VAR> 
is a cyclic list or not a list.</DD>
<DT class="pubdef"><A NAME="keysort/2"><STRONG>keysort</STRONG>(<VAR>+List, 
-Sorted</VAR>)</A></DT>
<DD class="defbody">
List is a proper list whose elements are <CODE><VAR>Key</VAR>-<VAR>Value</VAR></CODE>, 
that is, terms whose principal functor is (-)/2, whose first argument is 
the sorting key, and whose second argument is the satellite data to be 
carried along with the key. <A NAME="idx:keysort2:1007"></A><A class="pred" href="builtinlist.html#keysort/2">keysort/2</A> 
sorts <VAR>List</VAR> like <A NAME="idx:msort2:1008"></A><A class="pred" href="builtinlist.html#msort/2">msort/2</A>, 
but only compares the keys. It is used to sort terms not on standard 
order, but on any criterion that can be expressed on a multi-dimensional 
scale. Sorting on more than one criterion can be done using terms as 
keys, putting the first criterion as argument 1, the second as argument 
2, etc. The order of multiple elements that have the same <VAR>Key</VAR> 
is not changed. The implementation is in C, using <EM>natural merge sort</EM>. 
Fails with a <CODE>type_error</CODE> if <VAR>List</VAR> is a cyclic list 
or not a list or one of the elements of <VAR>List</VAR> is not a <EM>pair</EM>.</DD>
<DT class="pubdef"><A NAME="predsort/3"><STRONG>predsort</STRONG>(<VAR>+Pred, 
+List, -Sorted</VAR>)</A></DT>
<DD class="defbody">
Sorts similar to <A NAME="idx:sort2:1009"></A><A class="pred" href="builtinlist.html#sort/2">sort/2</A>, 
but determines the order of two terms by calling <VAR>Pred</VAR>(-<VAR>Delta</VAR>, 
+<VAR>E1</VAR>, +<VAR>E2</VAR>) . This call must unify <VAR>Delta</VAR> 
with one of <CODE><CODE>&lt;</CODE></CODE>, <CODE><CODE>&gt;</CODE></CODE> 
or
<CODE><CODE>=</CODE></CODE>. If built-in predicate <A NAME="idx:compare3:1010"></A><A class="pred" href="compare.html#compare/3">compare/3</A> 
is used, the result is the same as <A NAME="idx:sort2:1011"></A><A class="pred" href="builtinlist.html#sort/2">sort/2</A>. 
See also <A NAME="idx:keysort2:1012"></A><A class="pred" href="builtinlist.html#keysort/2">keysort/2</A>.<SUP class="fn">56<SPAN class="fn-text">Please 
note that the semantics have changed between 3.1.1 and 3.1.2</SPAN></SUP>
</DD>
</DL>

<P></BODY></HTML>